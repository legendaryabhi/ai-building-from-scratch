const fs = require("fs");
const axios = require("axios");
const { execSync } = require("child_process");

// ---------- CONFIG ----------
const MODEL = "gemini-2.5-flash";
const BRANCH = `ai-suggestions-${Date.now()}`;

// ---------- GEMINI KEY ----------
const GEMINI_KEY = process.env.GEMINI_API_KEY_1;
if (!GEMINI_KEY) {
  console.error("❌ GEMINI_API_KEY_1 missing");
  process.exit(1);
}

// ---------- HELPERS ----------
function run(cmd) {
  return execSync(cmd, { encoding: "utf8" });
}

// ---------- GEMINI RESEARCH ----------
async function getSuggestions() {
  const prompt = `
You are an AI research assistant.

Task:
Find NEW, high-signal resources related to AI systems.

Fields:
- AI Agents
- AI IDEs
- AI Models
- AI Trends

Rules:
- Only recent or still-relevant resources
- No hype or marketing
- Open-source or educational preferred
- Max 2 suggestions per field

IMPORTANT: Return ONLY JSON and in this format:
{
  "suggestions": [
    {
      "section": "AI Agents",
      "title": "Tool or Project name",
      "link": "https://...",
      "description": "1-line reason why it matters"
    }
  ]
}

you must return only json object.
`;

  let rawText;

  try {
    const res = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${GEMINI_KEY}`,
      { contents: [{ parts: [{ text: prompt }] }] }
    );

    rawText = res.data?.candidates?.[0]?.content?.parts?.[0]?.text;
  } catch (err) {
    console.error("❌ Gemini API call failed");
    console.error(err.message);
    return [];
  }

  if (!rawText) {
    console.warn("⚠️ Empty Gemini response");
    return [];
  }

  // -------- SAFE JSON EXTRACTION --------
  const jsonMatch = rawText.match(/\{[\s\S]*\}/);

  if (!jsonMatch) {
    console.warn("⚠️ No JSON found in Gemini output");
    console.warn("Raw output:", rawText);
    return [];
  }

  let parsed;
  try {
    parsed = JSON.parse(jsonMatch[0]);
  } catch (e) {
    console.warn("⚠️ Invalid JSON returned by Gemini");
    console.warn(jsonMatch[0]);
    return [];
  }

  // -------- STRUCTURE VALIDATION --------
  if (
    !parsed.suggestions ||
    !Array.isArray(parsed.suggestions)
  ) {
    console.warn("⚠️ JSON missing `suggestions` array");
    return [];
  }

  // -------- SANITIZE ENTRIES --------
  const cleaned = parsed.suggestions.filter(s =>
    s &&
    typeof s.section === "string" &&
    typeof s.title === "string" &&
    typeof s.link === "string" &&
    typeof s.description === "string"
  );

  if (cleaned.length === 0) {
    console.warn("⚠️ No valid suggestions after sanitization");
  }

  return cleaned;
}


// ---------- README PATCH ----------
function updateReadme(suggestions) {
  let readme = fs.readFileSync("README.md", "utf8");

  for (const s of suggestions) {
    const sectionRegex = new RegExp(`## ${s.section}[\\s\\S]*?(?=\\n## |$)`);
    const match = readme.match(sectionRegex);

    if (!match) continue;

    const bullet = `- **${s.title}** – ${s.description} (${s.link})\n`;

    if (match[0].includes(s.link)) continue; // avoid duplicates

    readme = readme.replace(match[0], match[0] + bullet);
  }

  fs.writeFileSync("README.md", readme);
}

// ---------- MAIN ----------
(async () => {
  const suggestions = await getSuggestions();

  if (suggestions.length === 0) {
    console.log("No new suggestions found.");
    return;
  }

  run(`git checkout -b ${BRANCH}`);
  updateReadme(suggestions);

  run(`git config user.name "autonomous-ai-bot"`);
  run(`git config user.email "bot@users.noreply.github.com"`);

  run(`git add README.md`);
  run(`git commit -m "chore: AI suggested updates"`);

  run(`git push origin ${BRANCH}`);

  run(
    `gh pr create \
      --title "AI: Suggested README updates" \
      --body "Automated suggestions generated by Gemini.\n\nReviewed by AI before merge." \
      --head ${BRANCH} \
      --base main`
  );

  console.log("✅ PR created successfully");
})();
